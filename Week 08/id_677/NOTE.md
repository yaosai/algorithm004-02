# NOTE
- 个人觉得动态规划的核心是，DP状态的定义，一旦状态定义OK，问题基本迎刃而解，状态定义是对问题的定性分析，需要理解并建模；
- DP方程，需要确定好初始状态，根据数学归纳法，逐步由dp[N - 1] => dp[N]，推导的过程一般包含累加，聚合，极值，相对而言比较简单；
- 字符串的匹配，是一个常见且重要的领域，如正则表达式匹配，倒排索引，分词；普通的字符串匹配算法，包括KMP，RK，BM算法等，学习其算法思想，包括中间计算值的缓存，利用上下文的相关性，提高程序效率。

## 63. 不同路径 II
- 一开始混淆了#63和#62两题，#62题没有障碍物，只需要逆向推导，由end=》start，其结果在dp[0][0]处，需要特别注意的是dp状态的初始化工作，一开始dp状态的二维数据结构，其底边和右侧边需要初始化为1
- #63题增加了障碍物，其推导方式的方向性与#62题相反，需要正向推导
- 国际站代码中的Java解法，使用到了state compression，有效减少了space complexity

```
dp[m][n] = (m, n) == 1 ? 0 : dp[m - 1][n] + dp[m][n - 1]
```
